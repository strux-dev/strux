/***
 *
 *
 *  Dev Command
 *
 *  Main entry point for the Strux dev tool
 *
 */

import path from "path"

import chokidar from "chokidar"

import { Settings } from "../../settings"
import { Logger } from "../../utils/log"
import { compileApplication } from "../build/steps"
import { build as buildCommand } from "../build"
import { MainYAMLValidator } from "../../types/main-yaml"
import { createDevServer, stopDevServer, type DevServer } from "./server"
import { run as runQEMU } from "../run"
import { DevUI } from "./ui"
import chalk from "chalk"


// Dev server instance
let devServer: DevServer | null = null

// QEMU process reference
let qemuProcess: Awaited<ReturnType<typeof runQEMU>> | null = null

// Vite dev server process reference
let viteProcess: ReturnType<typeof Bun.spawn> | null = null

// Dev UI reference
let devUI: DevUI | null = null

const consoleSessionId = "main"


export async function dev(): Promise<void> {


    // Enable dev mode
    Settings.isDevMode = true

    // Load and validate strux.yaml to get the client key and other settings
    MainYAMLValidator.validateAndLoad()

    // Determine BSP based on --remote flag
    if (Settings.isRemoteOnly) {

        // Remote mode: Use BSP from strux.yaml
        Logger.info("Remote mode: Using BSP from strux.yaml")

        if (!Settings.bspName) {

            Logger.errorWithExit("No BSP specified in strux.yaml. Please add a 'bsp' field.")

        }

    } else {

        // Local mode: Force QEMU BSP
        Logger.info("Local mode: Using QEMU BSP for development")

        Settings.bspName = "qemu"

    }

    // Get the client key from the config
    const clientKey = Settings.main?.dev?.server?.client_key ?? ""

    if (!clientKey) {

        Logger.errorWithExit("No client key found in strux.yaml. Please add a client_key under dev.server.")

    }

    // Get the server port from fallback hosts (default to 8000)
    const serverPort = Settings.main?.dev?.server?.fallback_hosts?.[0]?.port ?? 8000

    const cleanup = (exitCode = 0) => {
        Logger.setSink(null)
        devUI?.destroy()

        Logger.log("Shutting down...")

        stopDevServer()

        if (viteProcess) {
            viteProcess.kill()
        }

        if (qemuProcess && "kill" in qemuProcess) {
            qemuProcess.kill()
        }

        setTimeout(() => {
            process.exit(exitCode)
        }, 100)
    }

    // Initialize the TUI
    if (process.env.STRUX_DEV_NO_UI === "1") {
        Logger.warning("STRUX_DEV_NO_UI=1 set, using console output")
        devUI = null
    } else {
        try {
            devUI = new DevUI({
                onExit: () => cleanup(),
                onConsoleInput: (data) => {
                    if (!devServer?.isClientConnected()) {
                        Logger.warning("Console not connected yet")
                        return
                    }
                    devServer.sendExecInput(consoleSessionId, data)
                },
                initialStatus: "Starting dev session..."
            })
        } catch (error) {
            Logger.error(`Failed to start TUI, falling back to console logs: ${(error as Error).message}`)
            devUI = null
        }
    }

    // Helper to handle fatal errors - logs to UI and waits before exiting
    const handleFatalError = (error: Error | unknown, type: string) => {
        // Check if this is a controlled exit from Logger.errorWithExit
        // These errors are already logged, just need to wait for user to see them
        if (error instanceof Error && error.name === "StruxExitError") {
            // Already logged by Logger.errorWithExit, UI is showing the error
            // Don't exit automatically - let user press Q to exit
            return
        }

        const errorMessage = error instanceof Error
            ? `${error.message}\n${error.stack ?? ""}`
            : String(error)

        Logger.error(`${type}: ${errorMessage}`)

        // Give the UI time to render the error before exiting
        if (devUI) {
            devUI.appendLog("build", chalk.red(`\n[FATAL] ${type}: ${errorMessage}`))
            devUI.appendLog("build", chalk.yellow("\nPress Q to exit."))
            // Don't auto-exit, let user see the error and press Q
        } else {
            cleanup(1)
        }
    }

    // Set up global error handlers to capture uncaught errors in the UI
    process.on("uncaughtException", (error) => {
        handleFatalError(error, "Uncaught Exception")
    })

    process.on("unhandledRejection", (reason) => {
        handleFatalError(reason, "Unhandled Promise Rejection")
    })

    if (devUI) {
        const ui = devUI // Capture reference for closure
        Logger.setSink(({ level, message, formatted }) => {
            if (level === "spinner") {
                ui.setSpinnerLine(formatted ?? message)
                return
            }
            if (level === "spinner-clear") {
                ui.setSpinnerLine("")
                return
            }

            const output = formatted ?? message
            const lines = output.split("\n")
            for (const line of lines) {
                ui.appendLog("build", line)
            }
        })
    }

    if (Settings.isRemoteOnly && devUI) {
        devUI.setQemuTabLabel("Early Logs")
    }

    const useUi = devUI !== null

    // Run the initial build
    Logger.title("Building Development Image")

    try {
        await buildCommand()
    } catch (error) {
        // Handle StruxExitError specially - it's already been logged
        if (error instanceof Error && error.name === "StruxExitError") {
            // Error already logged to UI, wait for user to press Q
            if (useUi) {
                await new Promise((_resolve) => { /* Never resolves - UI handles exit via Q key */ })
            }
            return
        }
        // Re-throw other errors to be caught by global handler
        throw error
    }

    // Start the Vite dev server for the frontend inside Docker
    // This ensures consistent Linux-native npm packages and proper caching
    Logger.title("Starting Vite Dev Server (Docker)")

    // Build Docker command for Vite dev server
    // Uses the same strux-builder image with port mapping for HMR
    const viteDockerArgs: string[] = [
        "docker", "run", "--rm",
        "-v", `${Settings.projectPath}:/project`,
        "-p", "5173:5173",  // Vite dev server port
        "-w", "/project/frontend",
        // Enable polling for file watching (Docker doesn't propagate native fs events well)
        "-e", "CHOKIDAR_USEPOLLING=true",
        "-e", "CHOKIDAR_INTERVAL=100",
        "strux-builder",
        "/bin/bash", "-c",
        "npm install && npm run dev -- --host 0.0.0.0 --port 5173"
    ]

    viteProcess = Bun.spawn(viteDockerArgs, {
        stdio: useUi ? ["pipe", "pipe", "pipe"] : ["inherit", "inherit", "inherit"]
    })

    if (useUi && viteProcess.stdout) {
        streamLines(viteProcess.stdout as any, (line) => devUI?.appendLog("vite", line))
    }
    if (useUi && viteProcess.stderr) {
        streamLines(viteProcess.stderr as any, (line) => devUI?.appendLog("vite", line))
    }

    Logger.success("Vite dev server started on http://localhost:5173 (running in Docker)")

    // Handle Vite process exit
    viteProcess.exited.then((code) => {

        // Exit codes 130 (SIGINT) and 143 (SIGTERM) are expected when we kill the process
        const isSignalExit = code === 130 || code === 143

        if (code !== 0 && code !== null && !isSignalExit) {

            Logger.error(`Vite dev server exited with code ${code}`)

        }

    })

    // Start QEMU if not in remote mode
    if (!Settings.isRemoteOnly) {

        Logger.title("Starting QEMU Emulator")

        const proc = await runQEMU({
            devMode: true,
            returnProcess: true,
            stdio: useUi ? ["pipe", "pipe", "pipe"] : ["inherit", "inherit", "inherit"]
        })

        if (proc) {

            qemuProcess = proc

            if (useUi && proc.stdout) {
                streamLines(proc.stdout, (line) => devUI?.appendLog("qemu", line))
            }
            if (useUi && proc.stderr) {
                streamLines(proc.stderr, (line) => devUI?.appendLog("qemu", line))
            }

            // Display WebKit Inspector URL if explicitly enabled in strux.yaml
            const inspectorEnabled = Settings.main?.dev?.inspector?.enabled ?? false
            const inspectorPort = Settings.main?.dev?.inspector?.port ?? 9223

            if (inspectorEnabled) {

                Logger.info(`WebKit Inspector: http://localhost:${inspectorPort}`)
                Logger.info("(Open in any browser to debug the frontend)")

            }

            // Handle QEMU exit
            proc.exited.then((code) => {

                if (devUI) {
                    devUI.appendLog("qemu", `QEMU exited with code ${code}`)
                }

                if (code !== 0) {
                    Logger.error(`QEMU exited with code ${code}`)
                } else {
                    Logger.log("QEMU emulator stopped")
                }

                // Stop dev server and Vite when QEMU closes
                stopDevServer()

                if (viteProcess) {
                    viteProcess.kill()
                }

                // Give processes a moment to clean up, then exit
                setTimeout(() => {
                    cleanup(code ?? 0)
                }, 100)

            })

        }

    }

    // Start the dev server
    Logger.title("Starting Development Server")

    const uiHandlers = devUI ? (() => {
        const ui = devUI
        return {
            onLogLine: (payload: { streamId: string; line: string; service?: string; timestamp: string }) => {
                if (payload.streamId === "app") {
                    ui.appendLog("app", formatLogLine("app", payload.line, payload.service, payload.timestamp))
                } else if (payload.streamId === "cage") {
                    ui.appendLog("cage", formatLogLine("cage", payload.line, payload.service, payload.timestamp))
                } else if (payload.streamId === "system" || payload.streamId === "journalctl") {
                    ui.appendLog("system", formatLogLine(payload.streamId, payload.line, payload.service, payload.timestamp))
                } else if (payload.streamId === "early") {
                    ui.appendLog("qemu", formatLogLine(payload.streamId, payload.line, payload.service, payload.timestamp))
                } else {
                    ui.appendLog("system", formatLogLine(payload.streamId, payload.line, payload.service, payload.timestamp))
                }
            },
            onLogError: (payload: { streamId: string; error: string }) => {
                ui.appendLog("system", `Log error (${payload.streamId}): ${payload.error}`)
            },
            onBinaryAck: (payload: { status: string; message: string }) => {
                if (payload.status === "skipped") {
                    ui.appendLog("build", `Binary skipped: ${payload.message}`)
                } else if (payload.status === "updated") {
                    ui.appendLog("build", `Binary updated on device: ${payload.message}`)
                } else {
                    ui.appendLog("build", `Binary update failed: ${payload.message}`)
                }
            },
            onExecOutput: (payload: { data: string }) => {
                ui.appendConsoleChunk(payload.data)
                ui.setConsoleSessionActive(true)
            },
            onExecExit: (payload: { code: number }) => {
                ui.appendConsoleChunk(`\r\n[session exited: ${payload.code}]\r\n`)
                ui.setConsoleSessionActive(false)
                ui.setConsoleInputMode(false)
            },
            onExecError: (payload: { error: string }) => {
                ui.appendConsoleChunk(`\r\n[error] ${payload.error}\r\n`)
                ui.setConsoleSessionActive(false)
                ui.setConsoleInputMode(false)
            }
        }
    })() : {}

    devServer = createDevServer({
        port: serverPort,
        clientKey,
        onClientConnected: () => {

            Logger.success("Device connected to dev server")
            devUI?.setStatus(`Connected | ${Settings.isRemoteOnly ? "remote" : "qemu"} | port ${serverPort}`)

            devServer?.startExecSession(consoleSessionId, "/bin/sh")
            devUI?.setConsoleSessionActive(true)

            // Start streaming app logs (user's Go app output) unless disabled
            if (Settings.devAppDebug) {
                devServer?.startLogStream("app", "app")
            }

            // Start streaming cage logs (Cage/Cog compositor output)
            devServer?.startLogStream("cage", "cage")

            // Only start streaming system logs in debug mode
            if (Settings.devDebug) {
                devServer?.startLogStream("system", "journalctl")
            }

            if (Settings.isRemoteOnly) {
                devServer?.startLogStream("early", "early")
            }

        },
        onClientDisconnected: () => {

            Logger.warning("Device disconnected from dev server")
            devUI?.setStatus(`Disconnected | ${Settings.isRemoteOnly ? "remote" : "qemu"} | port ${serverPort}`)
            devUI?.setConsoleSessionActive(false)
            devUI?.setConsoleInputMode(false)

        },
        onBinaryRequested: async () => {

            // Client requested binary, send the current one without recompiling
            Logger.log("Binary requested by client, sending current binary...")

            await sendCurrentBinary()

        },
        ...uiHandlers
    })

    Logger.info(`Client key: ${clientKey}`)

    // Start the file watcher
    await runFileWatcher()

    process.on("SIGINT", cleanup)
    process.on("SIGTERM", cleanup)

    // Keep the process running
    await new Promise((_resolve) => { /* Never resolves - keeps process alive */ })

}


function streamLines(stream: ReadableStream<Uint8Array>, onLine: (line: string) => void): void {
    const reader = stream.getReader()
    const decoder = new TextDecoder()
    let buffer = ""

    const readLoop = async () => {
        while (true) {
            const result = await reader.read()
            if (result.done) break

            buffer += decoder.decode(result.value, { stream: true })
            const parts = buffer.split("\n")
            buffer = parts.pop() ?? ""

            for (const line of parts) {
                if (line.trim().length > 0) {
                    onLine(line)
                }
            }
        }

        if (buffer.trim().length > 0) {
            onLine(buffer)
        }
    }

    void readLoop()
}

function formatLogLine(streamId: string, line: string, service?: string, timestamp?: string): string {
    const ts = timestamp ? `${chalk.dim(timestamp)} ` : ""
    const svc = service ? `${chalk.cyan(`[${service}]`)} ` : ""

    if (streamId === "app") {
        return `${ts}${chalk.green.bold("[APP]")} ${svc}${chalk.green(line)}`
    }

    if (streamId === "cage") {
        return `${ts}${chalk.blue.bold("[CAGE]")} ${svc}${chalk.blue(line)}`
    }

    return `${ts}${chalk.magenta(`[${streamId}]`)} ${svc}${line}`
}


async function runFileWatcher(): Promise<void> {


    const watcher = chokidar.watch(Settings.projectPath, {
        ignored: (filePath: string, stats) => {
            // Ignore everything in frontend, dist, assets, bsp, and overlay directories
            const ignoreDirs = ["frontend/", "dist/", "assets/", "bsp/", "overlay/"]
            // Normalize path separators for cross-platform consistency
            const normalizedPath = filePath.replace(/\\/g, "/")
            for (const dir of ignoreDirs) {
                if (normalizedPath.includes(`/${dir}`) || normalizedPath.startsWith(`${dir}`)) {
                    return true
                }
            }
            if (!stats?.isFile?.()) return false
            return !(
                filePath.endsWith(".go") ||
                filePath.endsWith(".mod") ||
                filePath.endsWith(".yaml") || // This handles strux.yaml
                filePath.endsWith(".sum")
            )
        },
        persistent: true,
        ignoreInitial: true
    })

    watcher.on("all", async (_event, filePath) => {

        Logger.log("Changes detected, rebuilding application...")

        try {
            // Check if the file is a strux file
            if (filePath.endsWith(".yaml")) await triggerFullRebuild()
            else await rebuildApplication()
        } catch (error) {
            // Handle StruxExitError specially - it's already been logged to the UI
            if (error instanceof Error && error.name === "StruxExitError") {
                // Error already logged to UI, don't propagate - let user see it and continue
                Logger.warning("Build failed. Fix the error and save to retry.")
                return
            }
            // Re-throw other errors to be caught by global handler
            throw error
        }

    })

}


async function sendCurrentBinary(): Promise<void> {


    Logger.log("Sending current binary to client...")

    // Send the current binary without recompiling
    if (devServer?.isClientConnected()) {

        const bspName = Settings.bspName!

        // Read the compiled binary from the BSP cache directory
        const binaryPath = path.join(Settings.projectPath, "dist", "cache", bspName, "app", "main")

        const binaryFile = Bun.file(binaryPath)

        if (await binaryFile.exists()) {

            const binaryData = Buffer.from(await binaryFile.arrayBuffer())

            devServer.sendBinary(binaryData)

            Logger.success("Binary sent to device")

        } else {

            Logger.warning(`Compiled binary not found at ${binaryPath}`)

        }

    }

}


async function rebuildApplication(): Promise<void> {

    // Compile the application
    await compileApplication()

    // Stream the application to the connected client
    await sendCurrentBinary()

}


async function triggerFullRebuild(): Promise<void> {


    Settings.isDevMode = true

    // Reload the config in case it changed
    MainYAMLValidator.validateAndLoad()

    // Build the application
    await buildCommand()

}
