import { $ } from "bun"
import { join, dirname } from "path"
import {
    type IntrospectionOutput,
    type MethodDef,
    type FieldDef,
    type StructDef,
    validateIntrospection
} from "../../types/introspection"
import { STRUX_RUNTIME_TYPES } from "../../types/strux-runtime"

// Path to the compiled introspection binary (relative to this package)
const INTROSPECT_BINARY = "strux-introspect"

export interface GenerateTypesOptions {
  // Path to the user's main.go file
  mainGoPath: string;
  // Path to output directory (default: frontend/)
  outputDir?: string;
  // Output filename (default: strux.d.ts)
  outputFilename?: string;
  // Path to introspection binary (optional, will use bundled binary if not provided)
  introspectBinaryPath?: string;
}

export interface GenerateTypesResult {
  success: boolean;
  outputPath?: string;
  methodCount?: number;
  fieldCount?: number;
  structCount?: number;
  error?: string;
}

/**
 * Run the Go introspection tool and get JSON output
 */
export async function runIntrospection(
    mainGoPath: string,
    binaryPath?: string
): Promise<IntrospectionOutput> {
    const binary = binaryPath ?? INTROSPECT_BINARY

    try {
        const result = await $`${binary} ${mainGoPath}`.quiet()
        const output = result.stdout.toString()
        const data = JSON.parse(output)
        return validateIntrospection(data)
    } catch (error) {
        if (error instanceof Error) {
            throw new Error(`Failed to run introspection: ${error.message}`)
        }
        throw error
    }
}

/**
 * Generate TypeScript definition content from introspection data
 */
export function generateTypeScriptDefinitions(
    introspection: IntrospectionOutput
): string {
    const lines: string[] = []

    // Header
    lines.push("// Auto-generated TypeScript definitions for Strux bindings")
    lines.push("// This file is automatically generated. DO NOT EDIT")
    lines.push("")

    const { app, structs } = introspection

    // Generate interfaces for custom structs (excluding the app struct)
    const usedStructs = findUsedStructs(app, structs)
    for (const structName of usedStructs) {
        const structDef = structs[structName]
        if (structDef) {
            lines.push(`interface ${structName} {`)
            for (const field of structDef.fields) {
                lines.push(`  ${field.name}: ${field.tsType};`)
            }
            lines.push("}")
            lines.push("")
        }
    }

    // Generate the App interface
    lines.push(`interface ${app.name} {`)

    // Add fields
    for (const field of app.fields) {
        lines.push(`  ${field.name}: ${field.tsType};`)
    }

    // Add separator if both fields and methods exist
    if (app.fields.length > 0 && app.methods.length > 0) {
        lines.push("")
    }

    // Add methods
    for (const method of app.methods) {
        const params = formatMethodParams(method)
        const returnType = formatReturnType(method)
        lines.push(`  ${method.name}(${params}): ${returnType};`)
    }

    lines.push("}")
    lines.push("")

    // Add Strux runtime types (boot, etc.)
    lines.push(STRUX_RUNTIME_TYPES)
    lines.push("")

    // Generate Window interface augmentation with both user app and strux runtime
    lines.push("declare global {")
    lines.push("  const strux: Strux;")
    lines.push("  interface Window {")
    lines.push("    strux: Strux;")
    lines.push("    go: {")
    lines.push(`      ${app.packageName}: {`)
    lines.push(`        ${app.name}: ${app.name};`)
    lines.push("      }")
    lines.push("    }")
    lines.push("  }")
    lines.push("}")
    lines.push("")
    lines.push("export {};")

    return lines.join("\n")
}

/**
 * Generate .d.ts file from a Go main.go file
 */
export async function generateTypes(
    options: GenerateTypesOptions
): Promise<GenerateTypesResult> {
    const {
        mainGoPath,
        outputDir = join(dirname(mainGoPath), "frontend"),
        outputFilename = "strux.d.ts",
        introspectBinaryPath,
    } = options

    try {
    // Check if main.go exists
        const mainGoFile = Bun.file(mainGoPath)
        if (!(await mainGoFile.exists())) {
            return {
                success: false,
                error: `main.go not found at ${mainGoPath}`,
            }
        }

        // Run introspection
        const introspection = await runIntrospection(mainGoPath, introspectBinaryPath)

        // Generate TypeScript definitions
        const tsContent = generateTypeScriptDefinitions(introspection)

        // Ensure output directory exists
        await $`mkdir -p ${outputDir}`.quiet()

        // Write the .d.ts file
        const outputPath = join(outputDir, outputFilename)
        await Bun.write(outputPath, tsContent)

        return {
            success: true,
            outputPath,
            methodCount: introspection.app.methods.length,
            fieldCount: introspection.app.fields.length,
            structCount: Object.keys(introspection.structs).length,
        }
    } catch (error) {
        return {
            success: false,
            error: error instanceof Error ? error.message : String(error),
        }
    }
}

// Helper functions

function formatMethodParams(method: MethodDef): string {
    return method.params
        .map((param, index) => {
            const name = param.name ?? `arg${index}`
            return `${name}: ${param.tsType}`
        })
        .join(", ")
}

function formatReturnType(method: MethodDef): string {
    let baseType = "void"

    if (method.returnType) {
        baseType = method.returnType.tsType
        if (method.hasError) {
            baseType += " | null"
        }
    }

    return `Promise<${baseType}>`
}

function findUsedStructs(
    app: { fields: FieldDef[]; methods: MethodDef[] },
    structs: Record<string, StructDef>
): string[] {
    const used = new Set<string>()
    const knownStructNames = new Set(Object.keys(structs))

    // Check fields
    for (const field of app.fields) {
        checkTypeForStruct(field.tsType, knownStructNames, used)
    }

    // Check methods
    for (const method of app.methods) {
        for (const param of method.params) {
            checkTypeForStruct(param.tsType, knownStructNames, used)
        }
        if (method.returnType) {
            checkTypeForStruct(method.returnType.tsType, knownStructNames, used)
        }
    }

    return Array.from(used)
}

function checkTypeForStruct(
    tsType: string,
    knownStructs: Set<string>,
    used: Set<string>
): void {
    // Remove array suffix
    const baseType = tsType.replace(/\[\]$/, "")

    if (knownStructs.has(baseType)) {
        used.add(baseType)
    }
}

function kindStringToTS(kindStr: string): string {
    switch (kindStr) {
        case "string":
            return "string"
        case "int":
        case "int8":
        case "int16":
        case "int32":
        case "int64":
        case "uint":
        case "uint8":
        case "uint16":
        case "uint32":
        case "uint64":
        case "float32":
        case "float64":
            return "number"
        case "bool":
            return "boolean"
        case "slice":
        case "array":
            return "any[]"
        case "map":
            return "Record<string, any>"
        case "struct":
            return "object"
        case "ptr":
        case "interface":
            return "any"
        default:
            return "unknown"
    }
}
